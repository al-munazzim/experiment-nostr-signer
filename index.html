<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nostr Encrypt / Decrypt POC</title>
<script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: -apple-system, system-ui, sans-serif; max-width: 680px; margin: 2rem auto; padding: 0 1rem; color: #222; background: #fafafa; }
h1 { font-size: 1.4rem; margin-bottom: .3rem; }
p.sub { color: #666; margin-bottom: 1.2rem; font-size: .9rem; }

/* Tabs */
.tabs { display: flex; gap: 0; border-bottom: 2px solid #ccc; margin-bottom: 1.2rem; }
.tab-btn { padding: .6rem 1.2rem; border: 2px solid transparent; border-bottom: none; border-radius: 6px 6px 0 0; cursor: pointer; font-size: .9rem; font-weight: 600; background: #eee; color: #666; margin-bottom: -2px; }
.tab-btn.active { background: #fff; color: #222; border-color: #ccc; border-bottom-color: #fff; }
.tab-btn:hover:not(.active) { background: #e4e4e4; }
.tab-panel { display: none; }
.tab-panel.active { display: block; }

/* Sub-tabs (NIP-46 flows) */
.flow-tabs { display: flex; gap: .5rem; margin-bottom: 1rem; }
.flow-btn { padding: .4rem 1rem; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: .82rem; font-weight: 600; background: #f5f5f5; color: #555; }
.flow-btn.active { background: #e67e22; color: #fff; border-color: #e67e22; }
.flow-panel { display: none; }
.flow-panel.active { display: block; }

label { display: block; font-weight: 600; margin: .8rem 0 .25rem; font-size: .85rem; }
input, textarea, select { width: 100%; padding: .5rem; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: .85rem; }
textarea { height: 90px; resize: vertical; }
.buttons { display: flex; gap: .5rem; margin: .8rem 0; }
button { padding: .5rem 1.2rem; border: none; border-radius: 4px; cursor: pointer; font-size: .9rem; font-weight: 600; }
button:hover { opacity: .85; }
button:disabled { opacity: .5; cursor: not-allowed; }
.btn-encrypt { background: #4a90d9; color: #fff; }
.btn-decrypt { background: #5cb85c; color: #fff; }
.btn-connect { background: #e67e22; color: #fff; }
.btn-generate { background: #8e44ad; color: #fff; }
.btn-disconnect { background: #c0392b; color: #fff; font-size: .8rem; padding: .4rem .8rem; }

.status-box { margin-top: .8rem; padding: .5rem; border-radius: 4px; font-size: .85rem; display: none; }
.status-box.error { display: block; background: #fdd; color: #a00; border: 1px solid #e99; }
.status-box.ok { display: block; background: #dfd; color: #060; border: 1px solid #9c9; }
.status-box.warn { display: block; background: #ffe8c0; color: #855; border: 1px solid #dca; }

.conn-status { font-size: .8rem; padding: .4rem .6rem; border-radius: 4px; margin-bottom: .5rem; display: none; }
.conn-status.connecting { display: block; background: #ffe8c0; color: #855; border: 1px solid #dca; }
.conn-status.connected { display: block; background: #dfd; color: #060; border: 1px solid #9c9; }
.conn-status.error { display: block; background: #fdd; color: #a00; border: 1px solid #e99; }

.warning-box { background: #fdd; color: #a00; border: 1px solid #e99; padding: .7rem; border-radius: 4px; margin-bottom: .8rem; font-size: .85rem; }
.hidden { display: none !important; }

/* Connection Panel */
.conn-panel { background: #f7f7f7; border: 1px solid #ddd; border-radius: 6px; padding: .8rem; margin-bottom: 1rem; font-size: .82rem; }
.conn-panel .cp-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: .5rem; }
.conn-panel .cp-header .cp-state { font-weight: 700; }
.conn-panel .cp-state.st-connected { color: #060; }
.conn-panel .cp-state.st-disconnected { color: #a00; }
.conn-panel .cp-state.st-reconnecting { color: #855; }
.conn-panel .cp-row { margin: .25rem 0; color: #444; }
.conn-panel .cp-row span { font-family: monospace; user-select: all; }
.conn-panel .cp-actions { display: flex; gap: .4rem; margin-top: .6rem; }
.conn-panel .cp-actions button { font-size: .78rem; padding: .3rem .7rem; }
.btn-reconnect { background: #e67e22; color: #fff; border: none; border-radius: 4px; cursor: pointer; }
.btn-forget { background: #c0392b; color: #fff; border: none; border-radius: 4px; cursor: pointer; }
.btn-copy-sm { background: #888; color: #fff; border: none; border-radius: 3px; cursor: pointer; font-size: .72rem; padding: .15rem .4rem; margin-left: .3rem; }
.qr-box { text-align: center; margin: .8rem 0; }
.qr-box canvas, .qr-box img { max-width: 220px; }
.uri-display { word-break: break-all; font-size: .78rem; background: #f0f0f0; padding: .5rem; border-radius: 4px; margin: .5rem 0; font-family: monospace; user-select: all; }
.nip46-enc-row { margin-bottom: .5rem; }
</style>
</head>
<body>
<h1>üîê Nostr Encrypt / Decrypt</h1>
<p class="sub">Encrypt &amp; decrypt via NIP-07 extension or NIP-46 remote signer.</p>

<div class="tabs">
  <div class="tab-btn active" data-tab="nip04">NIP-04</div>
  <div class="tab-btn" data-tab="nip44">NIP-44</div>
  <div class="tab-btn" data-tab="nip46">NIP-46</div>
</div>

<!-- NIP-04 Tab -->
<div class="tab-panel active" id="panel-nip04">
  <div id="warn-nip04" class="warning-box hidden">
    <strong>No NIP-04 signer detected.</strong><br>
    Install a NIP-07 extension like <a href="https://getalby.com">Alby</a> or <a href="https://github.com/nicehash/nos2x">nos2x</a>.
  </div>
  <label>Recipient Public Key (hex or npub)</label>
  <input class="pubkey-input" data-mode="nip04" placeholder="hex pubkey or npub of the other party">
  <label>Plaintext</label>
  <textarea class="plain-input" data-mode="nip04" placeholder="Message to encrypt..."></textarea>
  <div class="buttons">
    <button class="btn-encrypt" data-mode="nip04">Encrypt ‚Üì</button>
    <button class="btn-decrypt" data-mode="nip04">Decrypt ‚Üë</button>
  </div>
  <label>Ciphertext</label>
  <textarea class="cipher-input" data-mode="nip04" placeholder="Encrypted payload appears here..."></textarea>
  <div class="status-box" data-mode="nip04"></div>
</div>

<!-- NIP-44 Tab -->
<div class="tab-panel" id="panel-nip44">
  <div id="warn-nip44" class="warning-box hidden">
    <strong>No NIP-44 signer detected.</strong><br>
    Install a NIP-07 extension with NIP-44 support.
  </div>
  <label>Recipient Public Key (hex or npub)</label>
  <input class="pubkey-input" data-mode="nip44" placeholder="hex pubkey or npub of the other party">
  <label>Plaintext</label>
  <textarea class="plain-input" data-mode="nip44" placeholder="Message to encrypt..."></textarea>
  <div class="buttons">
    <button class="btn-encrypt" data-mode="nip44">Encrypt ‚Üì</button>
    <button class="btn-decrypt" data-mode="nip44">Decrypt ‚Üë</button>
  </div>
  <label>Ciphertext</label>
  <textarea class="cipher-input" data-mode="nip44" placeholder="Encrypted payload appears here..."></textarea>
  <div class="status-box" data-mode="nip44"></div>
</div>

<!-- NIP-46 Tab -->
<div class="tab-panel" id="panel-nip46">
  <!-- Connection Panel (shown when connected or has stored session) -->
  <div class="conn-panel hidden" id="nip46-panel">
    <div class="cp-header">
      <span class="cp-state" id="cp-state">‚óè  Disconnected</span>
      <span style="font-size:.75rem;color:#888" id="cp-flow"></span>
    </div>
    <div class="cp-row">Signer: <span id="cp-pubkey"></span><button class="btn-copy-sm" id="cp-copy-pk" title="Copy full pubkey">üìã</button></div>
    <div class="cp-row">Relay: <span id="cp-relay"></span></div>
    <div class="cp-row" id="cp-since-row">Since: <span id="cp-since"></span></div>
    <div class="cp-actions">
      <button class="btn-reconnect hidden" id="cp-reconnect">Reconnect</button>
      <button class="btn-forget" id="cp-forget">Disconnect &amp; Forget</button>
    </div>
  </div>

  <div class="flow-tabs">
    <div class="flow-btn active" data-flow="bunker">Signer-initiated (bunker://)</div>
    <div class="flow-btn" data-flow="client">Client-initiated (nostrconnect://)</div>
  </div>

  <!-- Bunker flow -->
  <div class="flow-panel active" id="flow-bunker">
    <label>Bunker URL</label>
    <input id="bunker-url" type="text" placeholder="bunker://<pubkey>?relay=wss://relay.example.com&secret=...">
    <div class="conn-status" id="conn-bunker"></div>
    <button class="btn-connect" id="connectBunkerBtn" style="margin-top:.4rem">Connect to Bunker</button>
    <button class="btn-disconnect hidden" id="disconnectBunkerBtn" style="margin-top:.4rem">Disconnect</button>
  </div>

  <!-- Client-initiated flow -->
  <div class="flow-panel" id="flow-client">
    <label>Relay</label>
    <input id="client-relay" type="text" value="wss://relay.damus.io" placeholder="wss://relay.example.com">
    <button class="btn-generate" id="generateBtn" style="margin-top:.5rem">Generate nostrconnect:// URI</button>
    <button class="btn-disconnect hidden" id="disconnectClientBtn" style="margin-top:.4rem">Disconnect</button>
    <div id="nostrconnect-display" class="hidden">
      <label>Scan or paste this URI in your signer (e.g. <a href="https://github.com/greenart7c3/Amber/releases" target="_blank" style="color:#4a90d9">Amber for Android</a>):</label>
      <details style="margin:.5rem 0;font-size:.8rem;color:#888">
        <summary style="cursor:pointer;color:#4a90d9">How it looks in Amber ‚Üí</summary>
        <img src="amber-screenshot.jpg" alt="Amber app screenshot showing Paste from clipboard, Scan a QR Code, and permission approval options" style="max-width:100%;border-radius:6px;margin-top:.4rem;border:1px solid #333">
      </details>
      <div class="uri-display" id="nostrconnect-uri"></div>
      <div class="qr-box" id="nostrconnect-qr"></div>
    </div>
    <div class="conn-status" id="conn-client"></div>
  </div>

  <div class="nip46-enc-row">
    <label>Payload Encryption</label>
    <select id="nip46-enc">
      <option value="nip04">NIP-04 (legacy)</option>
      <option value="nip44">NIP-44 (recommended)</option>
    </select>
    <label>Request Timeout</label>
    <select id="nip46-timeout">
      <option value="30000">30 seconds</option>
      <option value="300000">5 minutes</option>
      <option value="18000000">5 hours</option>
    </select>
  </div>

  <label>Recipient Public Key (hex or npub)</label>
  <input class="pubkey-input" data-mode="nip46" placeholder="hex pubkey or npub of the other party">
  <label>Plaintext</label>
  <textarea class="plain-input" data-mode="nip46" placeholder="Message to encrypt..."></textarea>
  <div class="buttons">
    <button class="btn-encrypt" data-mode="nip46">Encrypt ‚Üì</button>
    <button class="btn-decrypt" data-mode="nip46">Decrypt ‚Üë</button>
  </div>
  <label>Ciphertext</label>
  <textarea class="cipher-input" data-mode="nip46" placeholder="Encrypted payload appears here..."></textarea>
  <div class="status-box" data-mode="nip46"></div>
</div>

<script type="module">
import { generateSecretKey, getPublicKey, finalizeEvent } from 'https://esm.sh/nostr-tools@2.10.4/pure';
import { encrypt as nip44encrypt, decrypt as nip44decrypt, getConversationKey } from 'https://esm.sh/nostr-tools@2.10.4/nip44';
import { bytesToHex, hexToBytes } from 'https://esm.sh/@noble/hashes@1.6.1/utils';
import { decode as nip19decode } from 'https://esm.sh/nostr-tools@2.10.4/nip19';

function resolveHexPubkey(input) {
  input = input.trim();
  if (input.startsWith('npub1')) {
    try { return nip19decode(input).data; } catch(e) { throw new Error('Invalid npub: ' + e.message); }
  }
  if (/^[0-9a-f]{64}$/i.test(input)) return input;
  throw new Error('Enter a 64-char hex pubkey or npub');
}

const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);

// ‚îÄ‚îÄ‚îÄ Tab switching ‚îÄ‚îÄ‚îÄ
$$('.tab-btn').forEach(btn => btn.addEventListener('click', () => {
  $$('.tab-btn').forEach(b => b.classList.remove('active'));
  $$('.tab-panel').forEach(p => p.classList.remove('active'));
  btn.classList.add('active');
  $('#panel-' + btn.dataset.tab).classList.add('active');
  updateUI();
}));

$$('.flow-btn').forEach(btn => btn.addEventListener('click', () => {
  $$('.flow-btn').forEach(b => b.classList.remove('active'));
  $$('.flow-panel').forEach(p => p.classList.remove('active'));
  btn.classList.add('active');
  $('#flow-' + btn.dataset.flow).classList.add('active');
  updateUI();
}));

function activeTab() {
  return $('.tab-btn.active')?.dataset.tab || 'nip04';
}

function activeFlow() {
  return $('.flow-btn.active')?.dataset.flow || 'bunker';
}

function statusFor(mode, msg, cls) {
  const el = $(`.status-box[data-mode="${mode}"]`);
  if (el) { el.textContent = msg; el.className = 'status-box ' + cls; }
}

function connStatusEl(id, msg, cls) {
  const el = $('#' + id);
  if (el) { el.textContent = msg; el.className = 'conn-status ' + cls; }
}

// ‚îÄ‚îÄ‚îÄ NIP-46 State ‚îÄ‚îÄ‚îÄ
let nip46 = null; // { sk, pk, remotePubkey, ws, connected, pending, flow, relay, connectedAt }

const SESSION_KEY = 'nip46-session';

function saveSession() {
  if (!nip46 || !nip46.connected || !nip46.remotePubkey) return;
  const data = {
    clientSecretKey: bytesToHex(nip46.sk),
    clientPubkey: nip46.pk,
    remotePubkey: nip46.remotePubkey,
    relay: nip46.relay,
    flow: nip46.flow,
    connectedAt: nip46.connectedAt || new Date().toISOString()
  };
  localStorage.setItem(SESSION_KEY, JSON.stringify(data));
}

function loadSession() {
  try { const d = localStorage.getItem(SESSION_KEY); return d ? JSON.parse(d) : null; } catch { return null; }
}

function clearSession() { localStorage.removeItem(SESSION_KEY); }

function updateConnPanel() {
  const panel = $('#nip46-panel');
  const sess = loadSession();
  if (!nip46 && !sess) { panel.classList.add('hidden'); return; }
  panel.classList.remove('hidden');

  const connected = nip46?.connected;
  const reconnecting = nip46 && !nip46.connected && nip46.remotePubkey;
  const stateEl = $('#cp-state');
  const reconnBtn = $('#cp-reconnect');

  if (connected) {
    stateEl.textContent = '‚óè Connected'; stateEl.className = 'cp-state st-connected';
    reconnBtn.classList.add('hidden');
  } else if (reconnecting) {
    stateEl.textContent = '‚óè Reconnecting‚Ä¶'; stateEl.className = 'cp-state st-reconnecting';
    reconnBtn.classList.add('hidden');
  } else {
    stateEl.textContent = '‚óè Disconnected'; stateEl.className = 'cp-state st-disconnected';
    reconnBtn.classList.remove('hidden');
  }

  const rpk = nip46?.remotePubkey || sess?.remotePubkey || '';
  const relay = nip46?.relay || sess?.relay || '';
  const flow = nip46?.flow || sess?.flow || '';
  const since = nip46?.connectedAt || sess?.connectedAt || '';

  $('#cp-pubkey').textContent = rpk ? rpk.slice(0, 8) + '‚Ä¶' + rpk.slice(-8) : '?';
  $('#cp-pubkey').dataset.full = rpk;
  $('#cp-relay').textContent = relay;
  $('#cp-flow').textContent = flow === 'bunker' ? 'bunker://' : flow === 'client' ? 'nostrconnect://' : '';
  if (since) {
    $('#cp-since').textContent = new Date(since).toLocaleString();
    $('#cp-since-row').style.display = '';
  } else {
    $('#cp-since-row').style.display = 'none';
  }
}

function autoFillRecipient() {
  if (nip46?.remotePubkey) {
    const inp = $(`.pubkey-input[data-mode="nip46"]`);
    if (inp && !inp.value.trim()) inp.value = nip46.remotePubkey;
  }
}

function onNip46Connected() {
  nip46.connectedAt = nip46.connectedAt || new Date().toISOString();
  saveSession();
  updateConnPanel();
  autoFillRecipient();
  updateUI();
}

function cleanup46() {
  if (nip46) {
    if (nip46.ws) try { nip46.ws.close(); } catch {}
    nip46 = null;
  }
  connStatusEl('conn-bunker', '', '');
  connStatusEl('conn-client', '', '');
  $('#disconnectBunkerBtn').classList.add('hidden');
  $('#disconnectClientBtn').classList.add('hidden');
  $('#nostrconnect-display').classList.add('hidden');
  updateConnPanel();
  updateUI();
}

function forgetSession() {
  cleanup46();
  clearSession();
  updateConnPanel();
}

function makeReq(method, params) {
  return { id: Array.from(crypto.getRandomValues(new Uint8Array(16))).map(b=>b.toString(16).padStart(2,'0')).join(''), method, params };
}

async function sendNip46(request) {
  if (!nip46 || !nip46.connected) throw new Error('Not connected');
  const s = nip46;
  const content = nip44encrypt(JSON.stringify(request), getConversationKey(s.sk, s.remotePubkey));
  const event = finalizeEvent({
    kind: 24133,
    created_at: Math.floor(Date.now() / 1000),
    tags: [['p', s.remotePubkey]],
    content
  }, s.sk);

  return new Promise((resolve, reject) => {
    const timeoutMs = parseInt($('#nip46-timeout')?.value || '30000');
    const timeoutLabel = timeoutMs < 60000 ? (timeoutMs/1000)+'s' : timeoutMs < 3600000 ? (timeoutMs/60000)+'min' : (timeoutMs/3600000)+'h';
    const timeout = setTimeout(() => { delete s.pending[request.id]; reject(new Error('NIP-46 request timed out (' + timeoutLabel + ')')); }, timeoutMs);
    s.pending[request.id] = { resolve, reject, timeout };
    s.ws.send(JSON.stringify(['EVENT', event]));
  });
}

function handleResponse(event) {
  if (!nip46) return;
  const s = nip46;
  try {
    const plain = nip44decrypt(event.content, getConversationKey(s.sk, s.remotePubkey));
    const resp = JSON.parse(plain);
    if (resp.id && s.pending[resp.id]) {
      const p = s.pending[resp.id];
      clearTimeout(p.timeout);
      delete s.pending[resp.id];
      if (resp.error) p.reject(new Error(resp.error));
      else p.resolve(resp.result);
    }
  } catch (e) { console.warn('NIP-46 parse error:', e); }
}

// ‚îÄ‚îÄ‚îÄ Bunker flow (signer-initiated) ‚îÄ‚îÄ‚îÄ
function parseBunkerUrl(url) {
  const m = url.match(/^bunker:\/\/([0-9a-f]{64})\??(.*)$/i);
  if (!m) throw new Error('Invalid bunker URL');
  const params = new URLSearchParams(m[2]);
  const relay = params.get('relay');
  if (!relay) throw new Error('Missing relay param');
  return { remotePubkey: m[1], relay, secret: params.get('secret') || '' };
}

function connectBunker() {
  cleanup46();
  const url = $('#bunker-url').value.trim();
  if (!url) { connStatusEl('conn-bunker', 'Enter a bunker URL', 'error'); return; }
  try {
    const { remotePubkey, relay, secret } = parseBunkerUrl(url);
    const sk = generateSecretKey();
    const pk = getPublicKey(sk);
    const connId = 'conn-bunker';

    connStatusEl(connId, 'Connecting to ' + relay + '‚Ä¶', 'connecting');
    const ws = new WebSocket(relay);
    nip46 = { sk, pk, remotePubkey, ws, connected: false, pending: {}, flow: 'bunker', relay };

    ws.onopen = () => {
      ws.send(JSON.stringify(['REQ', 'nip46', { kinds: [24133], '#p': [pk], since: Math.floor(Date.now() / 1000) - 5 }]));
      const req = makeReq('connect', [pk, secret]);
      const content = nip44encrypt(JSON.stringify(req), getConversationKey(sk, remotePubkey));
      const event = finalizeEvent({ kind: 24133, created_at: Math.floor(Date.now() / 1000), tags: [['p', remotePubkey]], content }, sk);
      const timeout = setTimeout(() => {
        if (nip46?.pending[req.id]) { delete nip46.pending[req.id]; connStatusEl(connId, 'Connect timed out', 'error'); }
      }, 30000);
      nip46.pending[req.id] = {
        resolve: () => { clearTimeout(timeout); nip46.connected = true; connStatusEl(connId, 'Connected ‚úì', 'connected'); $('#disconnectBunkerBtn').classList.remove('hidden'); onNip46Connected(); },
        reject: (e) => { clearTimeout(timeout); connStatusEl(connId, 'Rejected: ' + e.message, 'error'); },
        timeout
      };
      ws.send(JSON.stringify(['EVENT', event]));
    };

    ws.onmessage = (e) => {
      try {
        const msg = JSON.parse(e.data);
        if (msg[0] === 'EVENT' && msg[2]?.kind === 24133 && msg[2].pubkey === nip46?.remotePubkey) handleResponse(msg[2]);
      } catch {}
    };
    ws.onerror = () => connStatusEl(connId, 'WebSocket error', 'error');
    ws.onclose = () => { if (nip46?.flow === 'bunker') { nip46.connected = false; connStatusEl(connId, 'Disconnected', 'error'); updateUI(); } };
  } catch (e) { connStatusEl('conn-bunker', e.message, 'error'); }
}

// ‚îÄ‚îÄ‚îÄ Client-initiated flow (nostrconnect://) ‚îÄ‚îÄ‚îÄ
function generateNostrConnect() {
  cleanup46();
  const relay = $('#client-relay').value.trim();
  if (!relay) { connStatusEl('conn-client', 'Enter a relay URL', 'error'); return; }

  const sk = generateSecretKey();
  const pk = getPublicKey(sk);
  const secret = bytesToHex(crypto.getRandomValues(new Uint8Array(16)));
  const connId = 'conn-client';

  const uri = `nostrconnect://${pk}?relay=${encodeURIComponent(relay)}&secret=${secret}&name=Nostr+Signer+POC`;

  // Show URI + QR
  $('#nostrconnect-uri').textContent = uri;
  $('#nostrconnect-display').classList.remove('hidden');

  // Generate QR
  const qrDiv = $('#nostrconnect-qr');
  qrDiv.innerHTML = '';
  try {
    const qr = qrcode(0, 'M');
    qr.addData(uri);
    qr.make();
    qrDiv.innerHTML = qr.createSvgTag(4, 0);
  } catch (e) {
    qrDiv.textContent = '(QR generation failed)';
  }

  connStatusEl(connId, 'Waiting for signer to connect‚Ä¶', 'connecting');

  const ws = new WebSocket(relay);
  nip46 = { sk, pk, remotePubkey: null, ws, connected: false, pending: {}, flow: 'client', secret, relay };

  ws.onopen = () => {
    ws.send(JSON.stringify(['REQ', 'nip46', { kinds: [24133], '#p': [pk], since: Math.floor(Date.now() / 1000) - 5 }]));
  };

  const connectTimeout = setTimeout(() => {
    if (nip46 && !nip46.connected) {
      connStatusEl(connId, 'Timed out waiting for signer (60s)', 'error');
    }
  }, 60000);

  ws.onmessage = (e) => {
    try {
      const msg = JSON.parse(e.data);
      if (msg[0] !== 'EVENT' || msg[2]?.kind !== 24133) return;
      const evt = msg[2];

      if (!nip46.connected) {
        // Try to decrypt with the event author as remotePubkey
        try {
          const plain = nip44decrypt(evt.content, getConversationKey(sk, evt.pubkey));
          const resp = JSON.parse(plain);
          // The connect response: method should be absent (it's a response), and result should be the secret or "ack"
          // According to NIP-46: signer sends response with id matching... but for client-initiated,
          // the signer sends a response event. We validate the secret.
          if (resp.result === secret || resp.result === 'ack' || resp.result === 'ACK' || resp.id) {
            clearTimeout(connectTimeout);
            nip46.remotePubkey = evt.pubkey;
            nip46.connected = true;
            connStatusEl(connId, 'Connected to signer ‚úì (pubkey: ' + evt.pubkey.slice(0, 12) + '‚Ä¶)', 'connected');
            $('#disconnectClientBtn').classList.remove('hidden');
            onNip46Connected();
            return;
          }
        } catch {}
      } else if (evt.pubkey === nip46.remotePubkey) {
        handleResponse(evt);
      }
    } catch {}
  };

  ws.onerror = () => { clearTimeout(connectTimeout); connStatusEl(connId, 'WebSocket error', 'error'); };
  ws.onclose = () => {
    clearTimeout(connectTimeout);
    if (nip46?.flow === 'client') { nip46.connected = false; connStatusEl(connId, 'Disconnected', 'error'); updateUI(); }
  };
}

// ‚îÄ‚îÄ‚îÄ UI ‚îÄ‚îÄ‚îÄ
function updateUI() {
  const tab = activeTab();

  // NIP-04/44 warnings
  ['nip04', 'nip44'].forEach(m => {
    const proto = window.nostr?.[m];
    const warn = $(`#warn-${m}`);
    if (warn) warn.classList.toggle('hidden', !!proto);
  });

  // Button states
  $$('.btn-encrypt, .btn-decrypt').forEach(btn => {
    const mode = btn.dataset.mode;
    if (mode === 'nip46') {
      btn.disabled = !nip46?.connected;
    } else {
      btn.disabled = !window.nostr?.[mode];
    }
  });
}

$('#connectBunkerBtn').addEventListener('click', connectBunker);
$('#generateBtn').addEventListener('click', generateNostrConnect);
$('#disconnectBunkerBtn').addEventListener('click', cleanup46);
$('#disconnectClientBtn').addEventListener('click', cleanup46);

// ‚îÄ‚îÄ‚îÄ Encrypt / Decrypt ‚îÄ‚îÄ‚îÄ
async function doEncrypt(mode) {
  const rawPk = $(`.pubkey-input[data-mode="${mode}"]`).value.trim();
  const pt = $(`.plain-input[data-mode="${mode}"]`).value;
  if (!rawPk || !pt) { statusFor(mode, 'Provide pubkey and plaintext.', 'error'); return; }
  let pk;
  try { pk = resolveHexPubkey(rawPk); } catch(e) { statusFor(mode, e.message, 'error'); return; }

  try {
    let ct;
    if (mode === 'nip46') {
      const enc = $('#nip46-enc').value;
      const method = enc === 'nip44' ? 'nip44_encrypt' : 'nip04_encrypt';
      statusFor(mode, 'Encrypting via NIP-46 (' + enc.toUpperCase() + ')‚Ä¶', 'ok');
      ct = await sendNip46(makeReq(method, [pk, pt]));
    } else {
      statusFor(mode, 'Encrypting via ' + mode.toUpperCase() + '‚Ä¶', 'ok');
      ct = await window.nostr[mode].encrypt(pk, pt);
    }
    $(`.cipher-input[data-mode="${mode}"]`).value = ct;
    statusFor(mode, 'Encrypted OK.', 'ok');
  } catch (e) { statusFor(mode, 'Encrypt failed: ' + e.message, 'error'); }
}

async function doDecrypt(mode) {
  const rawPk = $(`.pubkey-input[data-mode="${mode}"]`).value.trim();
  const ct = $(`.cipher-input[data-mode="${mode}"]`).value.trim();
  if (!rawPk || !ct) { statusFor(mode, 'Provide pubkey and ciphertext.', 'error'); return; }
  let pk;
  try { pk = resolveHexPubkey(rawPk); } catch(e) { statusFor(mode, e.message, 'error'); return; }

  try {
    let pt;
    if (mode === 'nip46') {
      const enc = $('#nip46-enc').value;
      const method = enc === 'nip44' ? 'nip44_decrypt' : 'nip04_decrypt';
      statusFor(mode, 'Decrypting via NIP-46 (' + enc.toUpperCase() + ')‚Ä¶', 'ok');
      pt = await sendNip46(makeReq(method, [pk, ct]));
    } else {
      statusFor(mode, 'Decrypting via ' + mode.toUpperCase() + '‚Ä¶', 'ok');
      pt = await window.nostr[mode].decrypt(pk, ct);
    }
    $(`.plain-input[data-mode="${mode}"]`).value = pt;
    statusFor(mode, 'Decrypted OK.', 'ok');
  } catch (e) { statusFor(mode, 'Decrypt failed: ' + e.message, 'error'); }
}

$$('.btn-encrypt').forEach(btn => btn.addEventListener('click', () => doEncrypt(btn.dataset.mode)));
$$('.btn-decrypt').forEach(btn => btn.addEventListener('click', () => doDecrypt(btn.dataset.mode)));

// ‚îÄ‚îÄ‚îÄ Connection Panel buttons ‚îÄ‚îÄ‚îÄ
$('#cp-copy-pk').addEventListener('click', () => {
  const full = $('#cp-pubkey').dataset.full;
  if (full) navigator.clipboard.writeText(full).then(() => { $('#cp-copy-pk').textContent = '‚úì'; setTimeout(() => $('#cp-copy-pk').textContent = 'üìã', 1500); });
});
$('#cp-forget').addEventListener('click', forgetSession);
$('#cp-reconnect').addEventListener('click', autoReconnect);

// ‚îÄ‚îÄ‚îÄ Auto-reconnect ‚îÄ‚îÄ‚îÄ
function autoReconnect() {
  const sess = loadSession();
  if (!sess) return;
  cleanup46();

  const { clientSecretKey, clientPubkey, remotePubkey, relay, flow, connectedAt } = sess;
  const sk = hexToBytes(clientSecretKey);
  const pk = clientPubkey;
  const connId = flow === 'bunker' ? 'conn-bunker' : 'conn-client';

  // Switch to the right flow tab
  $$('.flow-btn').forEach(b => b.classList.remove('active'));
  $$('.flow-panel').forEach(p => p.classList.remove('active'));
  $(`.flow-btn[data-flow="${flow}"]`)?.classList.add('active');
  $(`#flow-${flow}`)?.classList.add('active');

  const ws = new WebSocket(relay);
  nip46 = { sk, pk, remotePubkey, ws, connected: false, pending: {}, flow, relay, connectedAt };
  updateConnPanel();

  ws.onopen = () => {
    ws.send(JSON.stringify(['REQ', 'nip46', { kinds: [24133], '#p': [pk], since: Math.floor(Date.now() / 1000) - 5 }]));
    // Send connect request
    const req = makeReq('connect', [pk, '']);
    const content = nip44encrypt(JSON.stringify(req), getConversationKey(sk, remotePubkey));
    const event = finalizeEvent({ kind: 24133, created_at: Math.floor(Date.now() / 1000), tags: [['p', remotePubkey]], content }, sk);
    const timeout = setTimeout(() => {
      if (nip46?.pending[req.id]) {
        delete nip46.pending[req.id];
        nip46.connected = false;
        updateConnPanel();
        connStatusEl(connId, 'Reconnect timed out', 'error');
      }
    }, 30000);
    nip46.pending[req.id] = {
      resolve: () => {
        clearTimeout(timeout);
        nip46.connected = true;
        connStatusEl(connId, 'Reconnected ‚úì', 'connected');
        if (flow === 'bunker') $('#disconnectBunkerBtn').classList.remove('hidden');
        else $('#disconnectClientBtn').classList.remove('hidden');
        onNip46Connected();
      },
      reject: (e) => {
        clearTimeout(timeout);
        nip46.connected = false;
        updateConnPanel();
        connStatusEl(connId, 'Reconnect rejected: ' + e.message, 'error');
      },
      timeout
    };
    ws.send(JSON.stringify(['EVENT', event]));
  };

  ws.onmessage = (e) => {
    try {
      const msg = JSON.parse(e.data);
      if (msg[0] === 'EVENT' && msg[2]?.kind === 24133 && msg[2].pubkey === nip46?.remotePubkey) handleResponse(msg[2]);
    } catch {}
  };
  ws.onerror = () => { connStatusEl(connId, 'WebSocket error during reconnect', 'error'); updateConnPanel(); };
  ws.onclose = () => {
    if (nip46) { nip46.connected = false; updateConnPanel(); connStatusEl(connId, 'Disconnected', 'error'); updateUI(); }
  };
}

// ‚îÄ‚îÄ‚îÄ Auto-reconnect on page load ‚îÄ‚îÄ‚îÄ
const storedSession = loadSession();
if (storedSession) {
  // Switch to NIP-46 tab
  $$('.tab-btn').forEach(b => b.classList.remove('active'));
  $$('.tab-panel').forEach(p => p.classList.remove('active'));
  $(`.tab-btn[data-tab="nip46"]`).classList.add('active');
  $('#panel-nip46').classList.add('active');
  updateConnPanel();
  autoReconnect();
}

setTimeout(updateUI, 500);
</script>
</body>
</html>